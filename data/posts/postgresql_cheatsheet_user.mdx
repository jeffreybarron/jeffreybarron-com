# psql command

See this link for full list of psql command options
https://www.postgresql.org/docs/devel/app-psql.html

## to execute SQL from psql clie

*`command`* must be either a command string that is completely parsable by the server (i.e., it contains no psql-specific features), or a single backslash command. Thus you cannot mix SQL and psql meta-commands within a `-c` option. To achieve that, you could use repeated `-c` options or pipe the string into psql, for example:

```shell
psql -c 'SELECT * FROM foo;'
```

# Connections

You need
Hostname
portNumber
databse name
username
password

## Login using postgres user (shell)

```bash
$ ssh -l postgres 200.34.22.75
postgres@200.34.22.75's password:
Linux localhost 4.9.0-9-amd64 #1 SMP Debian 4.9.168-1 (2019-04-12) x86_64
```

// Login as PostgreSQL superuser “postgres” on remote PostgreSQL server using ssh (Linux)

```bash
root@localhost:~# su - postgres
```

// Login as PostgreSQL superuser “postgres” (Linux)

---

## Enter postgres terminal (shell)

```bash
postgres@localhost:~$ psql
```

// Enter PostgreSQL Command Line via “psql” client (psql)

---

## Connect database (psql)

```bash
\c test
You are now connected to database "test" as user "postgres".
```

// Connect to a PostgreSQL database “test” as “postgres” user (psql)

---

## Check psql Client version (shell)

```bash
$ psql -V
```

(psql)

```shell
psql (PostgreSQL) 9.6.12
```

// Check psql client version (psql)

---

## Check Postgres server version (SQL)

```bash
select version();
```

// Check postgres server version (SQL)

# Users

## Create User

https://www.postgresql.org/docs/8.0/sql-createuser.html

```SQL
CREATE USER name [ [ WITH ] option [ ... ] ]

where option can be:

      SYSID uid
    | CREATEDB | NOCREATEDB
    | CREATEUSER | NOCREATEUSER
    | IN GROUP groupname [, ...]
    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'
    | VALID UNTIL 'abstime'

```

For Example

```sql
CREATE USER myadmin WITH PASSWORD 'veryhardpassword';
```

## Set/Reset postgres user password (psql)

```bash
\password username
```

// To set/reset a password for PostgreSQL database user (psql)
For example: Change password for current user “postgres”:

```bash
\password postgres
Enter new password: xxxx
Enter it again: xxxx
```

```sql
ALTER USER myadmin1 WITH PASSWORD 'mypassword';
```

---

## Show all users (psql)

```bash
select * from pg_user;
```

// Display PostgreSQL database users (SQL)

```bash
\du
                                   List of roles
 Role name |                         Attributes                           | Member of
-----------+------------------------------------------------------------+-----------
 testrole    |                                                            | {}
 postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS   | {}
```

// Display PostgreSQL database roles (psql)

---

## Login & enter postgres terminal (psql)

```bash
$ psql -U testuser mytest
Password for user testuser: ......
psql (9.6.12)
Type "help" for help.
```

// Login to PostgreSQL: psql -U user database (psql)

# Databases

## List databases (psql)

```bash
\l
```

// List all databases using \l (or \list) (psql)

---

## List databases, more details(psql)

```bash
\l+
```

---

## Connect to Database (psql)

```shell
\c [database-name]
```

---

## Help on `CREATE DATABASE` command syntax

```bash
\h CREATE DATABASE
```

// Help on SQL Command Syntax (For e.g. CREATE DATABASE) (psql)

## Create database (SQL)

```bash
CREATE DATABASE mytest;
```

// Creates a new database “mytest” (SQL)
By default, the owner of the database is the current login user.

## Create database (psql)

```bash
\c test
You are now connected to database "test" as user "postgres".
```

---

# Tables

## Show table (psql)

```bash
\d TABLE_NAME
```

// Show table definition including indexes, constraints & triggers (psql)

---

## Show details (psql)

```bash
\d+ TABLE_NAME
```

// More detailed table definition including description and physical disk size (psql)

---

## List tables from current schema (psql)

```bash
\dt
```

// List tables from current schema (psql)

---

## List tables from all schemas (psql)

```bash
\dt *.*
```

// List tables from all schemas (psql)

---

## List tables for a schema (psql)

```bash
\dt <name-of-schema>.*
```

// List the tables in a specific schema (psql)

---

## Copy table data to CSV file (psql (SQL))

```bash
\copy (SELECT * FROM __table_name__) TO 'file_path_and_name.csv' WITH CSV
```

// Export a table as CSV (psql)

---

## Check indexes for a table using sql (psql)

```bash
SELECT * FROM pg_indexes WHERE tablename='__table_name__' AND
schemaname='__schema_name__';
```

// Show table indexes (SQL)

---

## Collects statistics about the contents of tables (SQL)

```bash
ANALYZE [__table__]
```

// Analyze a table and store the results in the pg_statistic system catalog (SQL)
With no parameter, `ANALYZE` examines every table in the current database

---

## Adding comment on table/column (SQL)

```bash
Comment on table employee is 'Stores employee records';
```

// Comment on table (SQL)

```bash
Comment on column employee.ssn is 'Employee Social Security Number';
```

// Comment on column (SQL)

---

## Approximate Table Row count / Table Cardinality(SQL)

```bash
SELECT reltuples AS card FROM pg_class WHERE relname = '<table_name>';
```

// Use this to do fast (but not exact) counts from tables. Helpful if table has millions / billions of records and you just want estimated rows quickly. (SQL)

# Views

## [List views](https://postgrescheatsheet.com/#/views?id=list-views)

```bash
\dv
```

// List views from current schema (psql)

---

## [List views](https://postgrescheatsheet.com/#/views?id=list-views-1)

```bash
\dv *.*
```

// List views from all schemas (psql)

# Indexes

## [Create a new index on a table](https://postgrescheatsheet.com/#/indexes?id=create-a-new-index-on-a-table)

```bash
create index idx_employee_emp_name on employee using btree (emp_name asc);
```

// Create a new index on the emp_name column of employee table (SQL)

This index specifies “btree” as the index method and uses “asc” to store the index key column data in ascending order

---

## [View indexes of a table](https://postgrescheatsheet.com/#/indexes?id=view-indexes-of-a-table)

```bash
\d employee
postgres=# \d employee;
                                    Table "public.employee"
   Column   |         Type          |                         Modifiers
------------+-----------------------+-----------------------------------------------------------
 emp_id     | integer               | not null default nextval('employee_emp_id_seq'::regclass)
 emp_name   | character varying(50) | not null
 emp_salary | numeric(9,2)          | not null
Indexes:
    "employee_pkey" PRIMARY KEY, btree (emp_id)
    "idx_employee_emp_name" btree (emp_name)
```

// List indexes of a table along with table definition (psql)

---

## [List all indexes](https://postgrescheatsheet.com/#/indexes?id=list-all-indexes)

```bash
\di
                      List of relations
 Schema |         Name          | Type  |  Owner   |  Table
--------+-----------------------+-------+----------+----------
 public | employee_pkey         | index | postgres | employee
 public | idx_employee_emp_name | index | postgres | employee
(2 rows)
```

// List all indexes from all tables (psql)

---

## [Drop index from a table](https://postgrescheatsheet.com/#/indexes?id=drop-index-from-a-table)

```bash
drop index idx_employee_emp_name;
```

// Drop an existing index from a table (SQL)

# Functions

## [Create a new function](https://postgrescheatsheet.com/#/functions?id=create-a-new-function)

```bash
$$
CREATE FUNCTION add(integer, integer) RETURNS integer
 AS 'select $1 + $2;'
 LANGUAGE SQL
 IMMUTABLE
 RETURNS NULL ON NULL INPUT;
$$
```

// Create a function to add 2 integers (SQL)

This function takes 2 integers as parameters  
`IMMUTABLE` means that the function cannot modify the database and always returns the same result when given the same argument values

---

## [Calling function](https://postgrescheatsheet.com/#/functions?id=calling-function)

```bash
select add(5,9);
 add
-----
  14
(1 row)
```

// Function call (SQL)

---

## [List functions](https://postgrescheatsheet.com/#/functions?id=list-functions)

```bash
\df
                        List of functions
 Schema | Name | Result data type | Argument data types |  Type
--------+------+------------------+---------------------+--------
 public | add  | integer          | integer, integer    | normal
(1 row)
```

// Display all Functions (psql)

---

## [List functions](https://postgrescheatsheet.com/#/functions?id=list-functions-1)

```bash
\df+
```

// Display all Functions including addition information including owner, source code & description etc. (psql)

---

## [Edit function](https://postgrescheatsheet.com/#/functions?id=edit-function)

```bash
\ef myfunction
```

// Edit a function in default editor (psql)

[  
](https://postgrescheatsheet.com/#/queries)

# Constraints

## [Create a table with primary & unique constraints](https://postgrescheatsheet.com/#/constraints?id=create-a-table-with-primary-amp-unique-constraints)

```bash
$$
CREATE TABLE IF NOT EXISTS employee (
  emp_id SERIAL `PRIMARY` KEY,
  emp_name VARCHAR(50) NOT NULL,
  emp_ssn VARCHAR (30) NOT NULL `UNIQUE`,
  emp_salary NUMERIC(9,2) NOT NULL
);
$$
```

// Creates a new table with primary & unique key constraints (SQL)

---

## [Avoid Duplicate Records](https://postgrescheatsheet.com/#/constraints?id=avoid-duplicate-records)

```bash
INSERT INTO employee (emp_name, emp_ssn, emp_salary) values ('Rohit', '1234', 5000.0);
INSERT 0 1

INSERT INTO employee (emp_name, emp_ssn, emp_salary) values (Mason, '1234', 7500.0);
ERROR:  duplicate key value violates unique constraint "employee_emp_ssn_key"
DETAIL:  Key (emp_ssn)=(1234) already exists.
```

// Insert records in a table with unique key constraints specified (SQL)

This table uses emp_id as primary key column (Keyword “primary”) and a unique constraint (Keyword “unique”) is specified on employee social security number (emp_ssn) to avoid duplicate ssn being entered.

---

## [Create a table with check constraint](https://postgrescheatsheet.com/#/constraints?id=create-a-table-with-check-constraint)

```bash
$$
CREATE TABLE orders(
  ord_no integer,
  ord_date date,
  ord_qty numeric,
  ord_amount numeric `CHECK (ord_amount>0)`
);
$$
```

// Creates a new table with check constraint specified (SQL)

```bash
insert into orders(ord_no, ord_date, ord_qty, ord_amount) values (1, '2019-08-29', 1, 10);
INSERT 0 1

insert into orders(ord_no, ord_date, ord_qty, ord_amount) values (2, '2019-08-29', 1, 0);
ERROR:  new row for relation "orders" violates check constraint "orders_ord_amount_check"
DETAIL:  Failing row contains (2, 2019-08-29, 1, 0).
```

// Insert records in table with check constraints specified (SQL)

Check constraint (Keyword “check”) is specified on order amount (ord_amount > 0) on table so any records with ord_amount \<=0 will fail to insert

---

## [Define relation between two tables (foreign key constraint)](https://postgrescheatsheet.com/#/constraints?id=define-relation-between-two-tables-foreign-key-constraint)

```bash
$$
CREATE TABLE IF NOT EXISTS department (
  dept_id SERIAL PRIMARY KEY,
  dept_name VARCHAR(50) NOT NULL
);
$$
CREATE TABLE

$$
CREATE TABLE IF NOT EXISTS employee (
  emp_id SERIAL PRIMARY KEY,
  emp_name VARCHAR(50) NOT NULL,
  emp_ssn VARCHAR (30) NOT NULL UNIQUE,
  emp_salary NUMERIC(9,2) NOT NULL,
  emp_dept_id INTEGER `REFERENCES` department (dept_id)    -- Foreign Key
);
$$
CREATE TABLE
```

// Creates table department & employee and defines a relation of an employee to department using foreign key (“REFERENCES”) (SQL)

---

## [Check constraints on a table (using \d option)](https://postgrescheatsheet.com/#/constraints?id=check-constraints-on-a-table-using-d-option)

```bash
\d employee;
                                     Table "public.employee"
   Column    |         Type          |                         Modifiers
-------------+-----------------------+-----------------------------------------------------------
 emp_id      | integer               | not null default nextval('employee_emp_id_seq'::regclass)
. . .
Indexes:
    "employee_pkey" PRIMARY KEY, btree (emp_id)
    "employee_emp_ssn_key" UNIQUE CONSTRAINT, btree (emp_ssn)
Foreign-key constraints:
    "employee_emp_dept_id_fkey" FOREIGN KEY (emp_dept_id) REFERENCES department(dept_id)
```

// Display constraints on a table (using \d option) (psql)

# String functions, Operators & Identifiers

## String concatenate Operator [ String || String ]

```bash
select 'Gordon' || ' ' || 'Moore' As fullName;
   fullname
--------------
 Gordon Moore
(1 row)
```

// Concatenates two or more strings using “||”. (SQL)

This operator can be applied on table columns as well. e.g. “select first_name || ‘ ‘ || last_name As fullName from person”

---

## [Square & Cube Root Operator (|/ & ||/)](https://postgrescheatsheet.com/#/identifiers?id=square-amp-cube-root-operator-amp-)

```bash
select |/25 As sqrt;
 sqrt
------
    5
(1 row)
```

// Square root operator. (SQL)

```bash
select ||/125 As cubert;
 cubert
------
    5
(1 row)
```

// Cube root operator. (SQL)

---

## [Factorial Operator (!)](https://postgrescheatsheet.com/#/identifiers?id=factorial-operator-)

```bash
select 5! As factorial;
 factorial
-----------
       120
(1 row)
```

// Factorial operator. (SQL)

---

## [Binary Complement Operator (~)](https://postgrescheatsheet.com/#/identifiers?id=binary-complement-operator-)

```bash
select ~60 As compl;
 compl
----------
      -61
(1 row)
```

// Binary 2’s complement. This operator has flipping effect on bits. (SQL)

Assume if A = 60, now in binary format they will be as follows − A = 0011 1100 ~A = 1100 0011 (flipping bits. change 0 to 1 & 1 to 0)

---

## String lower & upper function [ lower(string), upper(string) ]

```bash
select lower('Rohit Kumawat') As lowerCase, upper('Rohit Kumawat') As upperCase;
   lowercase   |   uppercase
---------------+---------------
 rohit kumawat | ROHIT KUMAWAT
(1 row)
```

// Postgres lower & upper function (SQL)

---

## [Number of characters in string [ char_length(string) ]](https://postgrescheatsheet.com/#/identifiers?id=number-of-characters-in-string-char_lengthstring-)

```bash
select char_length('Arizona') as num_chars;
 num_chars
-----------
         7
(1 row)
```

// Number of characters in string (SQL)

---

## Location of specified substring [ position(substring in string) ]

```bash
select position('pan' in 'japan') As pos;
 pos
-----
   3
(1 row)
```

// Location of specified substring (SQL)

---

## Extract substring [ substring(string from [int] for [int] ]

```bash
select substring('postgres' from 3 for 3) As sub_string;
 sub_string
------------
 stg
(1 row)
```

// Extract substring ‘postgres’ starting from 3rd character upto 3 characters length (SQL)

---

## [Insert newline in SQL output](https://postgrescheatsheet.com/#/identifiers?id=insert-newline-in-sql-output)

```bash
postgres=# select 'line 1'||E'\n'||'line 2' As newline;
 newline
---------
 line 1 +
 line 2
(1 row)
```

// Insert new line using E’\n’ (SQL)

Another option is to use the chr() function. (E is used for the Escape String constant). Here’s a few other escape sequences: \b backspace \f form feed \n newline \r carriage return \t tab

---

## [Quote identifier](https://postgrescheatsheet.com/#/identifiers?id=quote-identifier)

```bash
Update "my table" set "a&b" = 0;
```

// Using double quotes as delimited identifier

This allows constructing table or column names that would otherwise not be possible, such as ones containing spaces or ampersands. Also double quotes are used for escaping reserved keywords in postgres

---

## Dollar-quoted String constant

```bash
select $$Maria’s dogs$$ As col;
 col
--------------------
 Maria’s dogs
(1 row)
```

// Use dollar quotes string constant instead of double quotes for strings (SQL)

If a string contains many single quotes or backslashes then Postgres has an alternative called “dollar quoting”.

# Queries

## [Create a new table](https://postgrescheatsheet.com/#/queries?id=create-a-new-table)

```bash
CREATE TABLE IF NOT EXISTS employee (
  emp_id SERIAL PRIMARY KEY,        -- AUTO_INCREMENT integer, as primary key
  emp_name VARCHAR(50) NOT NULL,
  emp_salary NUMERIC(9,2) NOT NULL
);
```

// Creates a new table (SQL)

---

## [Display table](https://postgrescheatsheet.com/#/queries?id=display-table)

```bash
\d employee
                                    Table "public.employee"
   Column   |         Type          |                         Modifiers
------------+-----------------------+-----------------------------------------------------------
 emp_id     | integer               | not null default nextval('employee_emp_id_seq'::regclass)
 emp_name   | character varying(50) | not null
 emp_salar  | numeric(9,2)          | not null
Indexes:
    "employee_pkey" PRIMARY KEY, btree (emp_id)
```

// Display table (psql)

---

## [Insert query](https://postgrescheatsheet.com/#/queries?id=insert-query)

```bash
INSERT INTO employee (emp_name, emp_salary) VALUES
('John', 5000),
('Jack', 4568.0),
('Robert',7500.50);
```

// Insert records into table (SQL)

---

## [Conditional select query](https://postgrescheatsheet.com/#/queries?id=conditional-select-query)

```bash
select * from employee where emp_salary >= 5000;
 emp_id | emp_name | emp_salary
--------+----------+------------
    1   | John     |    5000.00
    3   | Robert   |    7500.50
(2 rows)
```

// Select data based on filter condition (e.g. emp_salary >= 5000) (SQL)

---

## [Conditional update query (Safe Update);](https://postgrescheatsheet.com/#/queries?id=conditional-update-query-safe-update)

```bash
BEGIN;
  update employee set emp_salary = 6000 where emp_name = 'John';
COMMIT;
```

// Update record based on a condition (e.g. Update emp_salary for employee ‘John’) (SQL)

Records are not committed inside database unless you issue a commit. Updates can be undone as well if you issue ROLLBACK command instead of COMMIT.

---

## [Alter Table](https://postgrescheatsheet.com/#/queries?id=alter-table)

```bash
alter table employee add column dept_id integer;
ALTER TABLE
```

// Alter table to add a new column (e.g. add dept_id in employee table) (SQL)

```bash
alter table employee drop column dept_id;
ALTER TABLE
```

// Alter table to drop column (e.g. drop dept_id from employee table) (SQL)

---

## [Truncate Table](https://postgrescheatsheet.com/#/queries?id=truncate-table)

```bash
truncate only employee;
TRUNCATE TABLE
```

// Truncate table employee (SQL)

Truncating a table is a quick way to remove records from a table because it does not need to scan the table. Truncate is a not logged activity inside database. Truncating a table is also a lot easier than dropping the table and recreating it.

This is safe to use “ONLY” keyword so that you don’t accidentally truncate dependant/child tables.

```bash
truncate only tableA, tableB;
TRUNCATE TABLE
```

// Truncate multiple tables at once (SQL)

---

## [Conditional delete query (Rollback)](https://postgrescheatsheet.com/#/queries?id=conditional-delete-query-rollback)

```bash
BEGIN;
  delete from employee where emp_id = 2;
  select * from employee where emp_id = 2;
  emp_id | emp_name | emp_ssn | emp_salary | emp_dept_id
  --------+----------+---------+------------+-------------
  (0 rows)
ROLLBACK;

select * from employee where emp_id = 2;
 emp_id | emp_name | emp_ssn | emp_salary | emp_dept_id
--------+----------+---------+------------+-------------
      2 | Rohit    | 1234    |    5000.00 |           1
(1 row)
```

// Delete from employee based on filter condition (emp_id = 1) & then Rollback transaction (SQL)

---

## [Parameterized Statements](https://postgrescheatsheet.com/#/queries?id=parameterized-statements)

```bash
PREPARE myplan (int) AS SELECT * FROM employee where emp_id = $1;
```

// Creates a parameterized statement and stores query access plan on server (SQL)

```bash
EXECUTE myplan(2);
 emp_id | emp_name | emp_ssn | emp_salary | emp_dept_id
--------+----------+---------+------------+-------------
      2 | Rohit    | 1234    |    5000.00 |           1
(1 row)
```

// Executes query as per stored access plan providing value for parameters (e.g. $1=2) (SQL)

Parameterized statements are an effective way to write queries that use the same access plan irrespective of run time values provided.  
Applications like java use the JDBC API to create parameterized statements like this:

```bash
Int emp_id = 2;
con = getDBConnection();  // get database connection
PreparedStatement pstmt = con.prepareStatement("select * from employee where emp_id = ?"); // prepare parameterized statement
pstmt.setInt(1, emp_id); // provide runtime value
pstmt.execute();  // execute query
```
